<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Streamly.Internal.Data.Parser</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Parser.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">streamly-parsers10: Beautiful Streaming, Concurrent and Reactive Composition</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2020 Composewell Technologies</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Parser</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Accumulators</a></li><li><a href="#g:2">Element parsers</a></li><li><a href="#g:3">Sequence parsers</a></li><li><a href="#g:4">Binary Combinators</a><ul><li><a href="#g:5">Sequential Applicative</a></li><li><a href="#g:6">Parallel Applicatives</a></li><li><a href="#g:7">Sequential Interleaving</a></li><li><a href="#g:8">Sequential Alternative</a></li><li><a href="#g:9">Parallel Alternatives</a></li></ul></li><li><a href="#g:10">N-ary Combinators</a><ul><li><a href="#g:11">Sequential Collection</a></li><li><a href="#g:12">Sequential Repetition</a></li><li><a href="#g:13">Special cases</a></li></ul></li><li><a href="#g:14">Distribution</a><ul><li><a href="#g:15">Distribute to collection</a></li><li><a href="#g:16">Distribute to repetition</a></li><li><a href="#g:17">Interleaved collection</a></li><li><a href="#g:18">Interleaved repetition</a></li><li><a href="#g:19">Collection of Alternatives</a></li><li><a href="#g:20">Repeated Alternatives</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Fast backtracking parsers with stream fusion and native streaming
 capability.</p><p><code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> and <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:Alternative" title="Control.Applicative">Alternative</a></code> type class based
 combinators from the
 <a href="http://hackage.haskell.org/package/parser-combinators">parser-combinators</a>
 package can also be used with the <code><a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> type. However, there are two
 important differences between <code>parser-combinators</code> and the equivalent ones
 provided in this module in terms of performance:</p><p>1) <code>parser-combinators</code> use plain Haskell lists to collect the results, in a
 strict Monad like IO, the results are necessarily buffered before they can
 be consumed.  This may not perform optimally in streaming applications
 processing large amounts of data.  Equivalent combinators in this module can
 consume the results of parsing using a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>, thus providing a scalability
 and a composable consumer.</p><p>2) Several combinators in this module can be many times faster because of
 stream fusion. For example, <code><a href="Streamly-Internal-Data-Parser.html#v:many" title="Streamly.Internal.Data.Parser">many</a></code> combinator
 in this module is much faster than the <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:many" title="Control.Applicative">many</a></code> combinator
 of <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:Alternative" title="Control.Applicative">Alternative</a></code> type class.</p><h1>Errors</h1><p>Failing parsers in this module throw the <code><a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a></code> exception.</p><h1>Naming</h1><p>As far as possible, try that the names of the combinators in this module are
 consistent with:</p><ul><li><a href="https://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html">base/Text.ParserCombinators.ReadP</a></li><li><a href="http://hackage.haskell.org/package/parser-combinators">parser-combinators</a></li><li><a href="http://hackage.haskell.org/package/megaparsec">megaparsec</a></li><li><a href="http://hackage.haskell.org/package/attoparsec">attoparsec</a></li><li><a href="http://hackage.haskell.org/package/parsec">parsec</a></li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">newtype</span> <a href="#t:Parser">Parser</a> m a b = <a href="#v:MkParser">MkParser</a> {<ul class="subs"><li><a href="#v:runParser">runParser</a> :: <span class="keyword">forall</span> r. <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a -&gt; ((<a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> b) -&gt; m r) -&gt; m r</li></ul>}</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:ParseError">ParseError</a> = <a href="#v:ParseError">ParseError</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Step">Step</a> s b<ul class="subs"><li>= <a href="#v:Yield">Yield</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</li><li>| <a href="#v:Skip">Skip</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</li><li>| <a href="#v:Stop">Stop</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> b</li><li>| <a href="#v:Error">Error</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li></ul></li><li class="src short"><a href="#v:fromFold">fromFold</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:any">any</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:all">all</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:yield">yield</a> :: MonadCatch m =&gt; b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:yieldM">yieldM</a> :: MonadCatch m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:die">die</a> :: MonadCatch m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:dieM">dieM</a> :: MonadCatch m =&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:peek">peek</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a</li><li class="src short"><a href="#v:eof">eof</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a ()</li><li class="src short"><a href="#v:satisfy">satisfy</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a</li><li class="src short"><a href="#v:take">take</a> :: MonadCatch m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeEQ">takeEQ</a> :: MonadCatch m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeGE">takeGE</a> :: MonadCatch m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:lookAhead">lookAhead</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeWhile">takeWhile</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeWhile1">takeWhile1</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceSepBy">sliceSepBy</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceSepByMax">sliceSepByMax</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceEndWith">sliceEndWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceBeginWith">sliceBeginWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:wordBy">wordBy</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:groupBy">groupBy</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:eqBy">eqBy</a> :: MonadCatch m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a ()</li><li class="src short"><a href="#v:splitWith">splitWith</a> :: MonadCatch m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c</li><li class="src short"><a href="#v:split_">split_</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b</li><li class="src short"><a href="#v:teeWith">teeWith</a> :: MonadCatch m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c</li><li class="src short"><a href="#v:teeWithFst">teeWithFst</a> :: MonadCatch m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c</li><li class="src short"><a href="#v:teeWithMin">teeWithMin</a> :: MonadCatch m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c</li><li class="src short"><a href="#v:deintercalate">deintercalate</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a y -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b z -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x (y, z)</li><li class="src short"><a href="#v:alt">alt</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a</li><li class="src short"><a href="#v:shortest">shortest</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a</li><li class="src short"><a href="#v:longest">longest</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a</li><li class="src short"><a href="#v:sequence">sequence</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:concatMap">concatMap</a> :: MonadCatch m =&gt; (b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:count">count</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:countBetween">countBetween</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:many">many</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:some">some</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:manyTill">manyTill</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a x -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:choice">choice</a> :: t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">newtype</span> <a id="t:Parser" class="def">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.ParserK.Types.html#Parser" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:MkParser" class="def">MkParser</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:runParser" class="def">runParser</a> :: <span class="keyword">forall</span> r. <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a -&gt; ((<a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> b) -&gt; m r) -&gt; m r</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div><div class="subs instances"><details id="i:Parser" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Monad:1"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.ParserK.Types.html#line-123" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p>Monad composition can be used for lookbehind parsers, we can make the
 future parses depend on the previously parsed values.</p><p>If we have to parse &quot;a9&quot; or &quot;9a&quot; but not &quot;99&quot; or &quot;aa&quot; we can use the
 following parser:</p><pre>backtracking :: MonadCatch m =&gt; PR.Parser m Char String
backtracking =
    sequence [PR.satisfy isDigit, PR.satisfy isAlpha]
    <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code>
    sequence [PR.satisfy isAlpha, PR.satisfy isDigit]
</pre><p>We know that if the first parse resulted in a digit at the first place then
 the second parse is going to fail.  However, we waste that information and
 parse the first character again in the second parse only to know that it is
 not an alphabetic char.  By using lookbehind in a <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> composition we can
 avoid redundant work:</p><pre>data DigitOrAlpha = Digit Char | Alpha Char

lookbehind :: MonadCatch m =&gt; PR.Parser m Char String
lookbehind = do
    x1 &lt;-    Digit <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> PR.satisfy isDigit
         <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code> Alpha <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> PR.satisfy isAlpha

    -- Note: the parse depends on what we parsed already
    x2 &lt;- case x1 of
        Digit _ -&gt; PR.satisfy isAlpha
        Alpha _ -&gt; PR.satisfy isDigit

    return $ case x1 of
        Digit x -&gt; [x,x2]
        Alpha x -&gt; [x,x2]
</pre><p>Seel also <code><a href="Streamly-Internal-Data-Parser.html#v:concatMap" title="Streamly.Internal.Data.Parser">concatMap</a></code>. This monad instance
 does not fuse, use <code><a href="Streamly-Internal-Data-Parser.html#v:concatMap" title="Streamly.Internal.Data.Parser">concatMap</a></code> when you need
 fusion.</p></td></tr><tr><td colspan="2"><details id="i:id:Parser:Monad:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserK-Types.html">Streamly.Internal.Data.Parser.ParserK.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; (a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:return" class="selflink">#</a></p><p class="src"><a href="#v:fail">fail</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:fail" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Functor:2"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.ParserK.Types.html#line-45" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p>Maps a function over the output of the fold.</p></td></tr><tr><td colspan="2"><details id="i:id:Parser:Functor:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserK-Types.html">Streamly.Internal.Data.Parser.ParserK.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Applicative:3"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.ParserK.Types.html#line-66" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> form of <code><a href="Streamly-Internal-Data-Parser.html#v:splitWith" title="Streamly.Internal.Data.Parser">splitWith</a></code>. Note that
 this operation does not fuse, use <code><a href="Streamly-Internal-Data-Parser.html#v:splitWith" title="Streamly.Internal.Data.Parser">splitWith</a></code>
 when fusion is important.</p></td></tr><tr><td colspan="2"><details id="i:id:Parser:Applicative:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserK-Types.html">Streamly.Internal.Data.Parser.ParserK.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a0 -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Alternative:4"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.ParserK.Types.html#line-147" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a></code> form of <code><a href="Streamly-Internal-Data-Parser.html#v:alt" title="Streamly.Internal.Data.Parser">alt</a></code>. Backtrack and
 run the second parser if the first one fails.</p><p>The &quot;some&quot; and &quot;many&quot; operations of alternative accumulate results in a pure
 list which is not scalable and streaming. Instead use
 <code><a href="Streamly-Internal-Data-Parser.html#v:some" title="Streamly.Internal.Data.Parser">some</a></code> and
 <code><a href="Streamly-Internal-Data-Parser.html#v:many" title="Streamly.Internal.Data.Parser">many</a></code> for fusible operations with composable
 accumulation of results.</p><p>See also <code><a href="Streamly-Internal-Data-Parser.html#v:alt" title="Streamly.Internal.Data.Parser">alt</a></code>. This <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a></code> instance
 does not fuse, use <code><a href="Streamly-Internal-Data-Parser.html#v:alt" title="Streamly.Internal.Data.Parser">alt</a></code> when you need
 fusion.</p></td></tr><tr><td colspan="2"><details id="i:id:Parser:Alternative:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserK-Types.html">Streamly.Internal.Data.Parser.ParserK.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:empty">empty</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:empty" class="selflink">#</a></p><p class="src"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:-60--124--62-" class="selflink">#</a></p><p class="src"><a href="#v:some">some</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a [a0] <a href="#v:some" class="selflink">#</a></p><p class="src"><a href="#v:many">many</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a [a0] <a href="#v:many" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:MonadPlus:5"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.ParserK.Types.html#line-164" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:mzero" title="Control.Monad">mzero</a></code> is same as <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:empty" title="Control.Applicative">empty</a></code>, it aborts the parser. <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:mplus" title="Control.Monad">mplus</a></code> is same as
 <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code>, it selects the first succeeding parser.</p><p><em>Internal</em></p></td></tr><tr><td colspan="2"><details id="i:id:Parser:MonadPlus:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserK-Types.html">Streamly.Internal.Data.Parser.ParserK.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mzero">mzero</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:mzero" class="selflink">#</a></p><p class="src"><a href="#v:mplus">mplus</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:mplus" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a id="t:ParseError" class="def">ParseError</a> <a href="src/Streamly.Internal.Data.Parser.ParserD.Types.html#ParseError" class="link">Source</a> <a href="#t:ParseError" class="selflink">#</a></p><div class="doc"><p>This exception is used for two purposes:</p><ul><li>When a parser ultimately fails, the user of the parser is intimated via
    this exception.</li><li>When the &quot;extract&quot; function of a parser needs to throw an error.</li></ul><p><em>Internal</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:ParseError" class="def">ParseError</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><details id="i:ParseError" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParseError:Show:1"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a></span> <a href="src/Streamly.Internal.Data.Parser.ParserD.Types.html#line-216" class="link">Source</a> <a href="#t:ParseError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParseError:Show:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserD-Types.html">Streamly.Internal.Data.Parser.ParserD.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParseError:Exception:2"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a></span> <a href="src/Streamly.Internal.Data.Parser.ParserD.Types.html#line-218" class="link">Source</a> <a href="#t:ParseError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParseError:Exception:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserD-Types.html">Streamly.Internal.Data.Parser.ParserD.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toException">toException</a> :: <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a> <a href="#v:toException" class="selflink">#</a></p><p class="src"><a href="#v:fromException">fromException</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Maybe.html#t:Maybe" title="GHC.Maybe">Maybe</a> <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a> <a href="#v:fromException" class="selflink">#</a></p><p class="src"><a href="#v:displayException">displayException</a> :: <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:displayException" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Step" class="def">Step</a> s b <a href="src/Streamly.Internal.Data.Parser.ParserD.Types.html#Step" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></p><div class="doc"><p>The return type of a <code><a href="Streamly-Internal-Data-Parser-ParserD-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserD.Types">Parser</a></code> step.</p><p>A parser is driven by a parse driver one step at a time, at any time the
 driver may <code>extract</code> the result of the parser. The parser may ask the driver
 to backtrack at any point, therefore, the driver holds the input up to a
 point of no return in a backtracking buffer.  The buffer grows or shrinks
 based on the return values of the parser step execution.</p><p>When a parser step is executed it generates a new intermediate state of the
 parse result along with a command to the driver. The command tells the
 driver whether to keep the input stream for a potential backtracking later
 on or drop it, and how much to keep. The constructors of <code><a href="Streamly-Internal-Data-Parser.html#t:Step" title="Streamly.Internal.Data.Parser">Step</a></code> represent
 the commands to the driver.</p><p><em>Internal</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Yield" class="def">Yield</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</td><td class="doc"><p><code>Yield offset state</code> indicates that the parser has yielded a new
 result which is a point of no return. The result can be extracted
 using <code>extract</code>. The driver drops the buffer except <code>offset</code> elements
 before the current position in stream. The rule is that if a parser
 has yielded at least once it cannot return a failure result.</p></td></tr><tr><td class="src"><a id="v:Skip" class="def">Skip</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</td><td class="doc"><p><code>Skip offset state</code> indicates that the parser has consumed the current
 input but no new result has been generated. A new <code>state</code> is generated.
 However, if we use <code>extract</code> on <code>state</code> it will generate a result from
 the previous <code>Yield</code>.  When <code>offset</code> is non-zero it is a backward offset
 from the current position in the stream from which the driver will feed
 the next input to the parser. The offset cannot be beyond the latest
 point of no return created by <code>Yield</code>.</p></td></tr><tr><td class="src"><a id="v:Stop" class="def">Stop</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> b</td><td class="doc"><p><code>Stop offset result</code> asks the driver to stop driving the parser
 because it has reached a fixed point and further input will not change
 the result.  <code>offset</code> is the count of unused elements which includes the
 element on which <code><a href="Streamly-Internal-Data-Parser.html#v:Stop" title="Streamly.Internal.Data.Parser">Stop</a></code> occurred.</p></td></tr><tr><td class="src"><a id="v:Error" class="def">Error</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc"><p>An error makes the parser backtrack to the last checkpoint and try
 another alternative.</p></td></tr></table></div><div class="subs instances"><details id="i:Step" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Step:Functor:1"></span> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Parser.html#t:Step" title="Streamly.Internal.Data.Parser">Step</a> s)</span> <a href="src/Streamly.Internal.Data.Parser.ParserD.Types.html#line-186" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Step:Functor:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserD-Types.html">Streamly.Internal.Data.Parser.ParserD.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Step" title="Streamly.Internal.Data.Parser">Step</a> s a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Step" title="Streamly.Internal.Data.Parser">Step</a> s b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Step" title="Streamly.Internal.Data.Parser">Step</a> s b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Step" title="Streamly.Internal.Data.Parser">Step</a> s a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:1" id="g:1"><h1>Accumulators</h1></a><div class="top"><p class="src"><a id="v:fromFold" class="def">fromFold</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#fromFold" class="link">Source</a> <a href="#v:fromFold" class="selflink">#</a></p><div class="doc"><p>Make a <code><a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> from a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:any" class="def">any</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Parser.html#any" class="link">Source</a> <a href="#v:any" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.any (== 0)) $ S.fromList [1,0,1]
</code></strong>&gt; True
</pre></div></div><div class="top"><p class="src"><a id="v:all" class="def">all</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Parser.html#all" class="link">Source</a> <a href="#v:all" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.all (== 0)) $ S.fromList [1,0,1]
</code></strong>&gt; False
</pre></div></div><div class="top"><p class="src"><a id="v:yield" class="def">yield</a> :: MonadCatch m =&gt; b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#yield" class="link">Source</a> <a href="#v:yield" class="selflink">#</a></p><div class="doc"><p>A parser that always yields a pure value without consuming any input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:yieldM" class="def">yieldM</a> :: MonadCatch m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#yieldM" class="link">Source</a> <a href="#v:yieldM" class="selflink">#</a></p><div class="doc"><p>A parser that always yields the result of an effectful action without
 consuming any input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:die" class="def">die</a> :: MonadCatch m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#die" class="link">Source</a> <a href="#v:die" class="selflink">#</a></p><div class="doc"><p>A parser that always fails with an error message without consuming
 any input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:dieM" class="def">dieM</a> :: MonadCatch m =&gt; m <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#dieM" class="link">Source</a> <a href="#v:dieM" class="selflink">#</a></p><div class="doc"><p>A parser that always fails with an effectful error message and without
 consuming any input.</p><p><em>Internal</em></p></div></div><a href="#g:2" id="g:2"><h1>Element parsers</h1></a><div class="top"><p class="src"><a id="v:peek" class="def">peek</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a <a href="src/Streamly.Internal.Data.Parser.html#peek" class="link">Source</a> <a href="#v:peek" class="selflink">#</a></p><div class="doc"><p>Peek the head element of a stream, without consuming it. Fails if it
 encounters end of input.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse ((,) &lt;$&gt; PR.peek &lt;*&gt; PR.satisfy (&gt; 0)) $ S.fromList [1]
</code></strong>(1,1)
</pre><pre>peek = lookAhead (satisfy True)
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:eof" class="def">eof</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a () <a href="src/Streamly.Internal.Data.Parser.html#eof" class="link">Source</a> <a href="#v:eof" class="selflink">#</a></p><div class="doc"><p>Succeeds if we are at the end of input, fails otherwise.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse ((,) &lt;$&gt; PR.satisfy (&gt; 0) &lt;*&gt; PR.eof) $ S.fromList [1]
</code></strong>&gt; (1,())
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:satisfy" class="def">satisfy</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a <a href="src/Streamly.Internal.Data.Parser.html#satisfy" class="link">Source</a> <a href="#v:satisfy" class="selflink">#</a></p><div class="doc"><p>Returns the next element if it passes the predicate, fails otherwise.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.satisfy (== 1)) $ S.fromList [1,0,1]
</code></strong>&gt; 1
</pre><p><em>Internal</em></p></div></div><a href="#g:3" id="g:3"><h1>Sequence parsers</h1></a><div class="doc"><p>Parsers chained in series, if one parser terminates the composition
 terminates.</p><p>TODO: Currently we are using folds to collect the output of the parsers
 but we can use Parsers instead of folds to make the composition more
 powerful. For example, we can do:</p><pre>sliceSepByMax cond n p = sliceBy cond (take n p)
sliceSepByBetween cond m n p = sliceBy cond (takeBetween m n p)
takeWhileBetween cond m n p = takeWhile cond (takeBetween m n p)
</pre><p>TODO: Like toList fold we can have toNonEmpty Parser to fold to a
 nonempty list. If we cannot collect even one element the parser will
 fail.  toNonEmpty can be used in takeWhile to implement takeWhile1.</p></div><div class="doc"><p>Grab a sequence of input elements without inspecting them</p></div><div class="top"><p class="src"><a id="v:take" class="def">take</a> :: MonadCatch m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#take" class="link">Source</a> <a href="#v:take" class="selflink">#</a></p><div class="doc"><p>Take at most <code>n</code> input elements and fold them using the supplied fold.</p><p>Stops after <code>n</code> elements.
 Never fails.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.take 1 FL.toList) $ S.fromList [1]
</code></strong>[1]
</pre><pre>S.chunksOf n f = S.splitParse (FL.take n f)
</pre><p><em>Internal</em></p></div></div><div class="doc"><p>Note: this is called takeP in some parser libraries.</p><p>TODO Once we have terminating folds, this Parse should get replaced by Fold.
 Alternatively, we can name it &quot;chunkOf&quot; and the corresponding time domain
 combinator as &quot;intervalOf&quot; or even &quot;chunk&quot; and &quot;interval&quot;.</p></div><div class="top"><p class="src"><a id="v:takeEQ" class="def">takeEQ</a> :: MonadCatch m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeEQ" class="link">Source</a> <a href="#v:takeEQ" class="selflink">#</a></p><div class="doc"><p>Stops after taking exactly <code>n</code> input elements.</p><ul><li>Stops - after <code>n</code> elements.</li><li>Fails - if the stream ends before it can collect <code>n</code> elements.</li></ul><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.takeEQ 4 FL.toList) $ S.fromList [1,0,1]
</code></strong>&gt; &quot;takeEQ: Expecting exactly 4 elements, got 3&quot;
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:takeGE" class="def">takeGE</a> :: MonadCatch m =&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeGE" class="link">Source</a> <a href="#v:takeGE" class="selflink">#</a></p><div class="doc"><p>Take at least <code>n</code> input elements, but can collect more.</p><ul><li>Stops - never.</li><li>Fails - if the stream end before producing <code>n</code> elements.</li></ul><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.takeGE 4 FL.toList) $ S.fromList [1,0,1]
</code></strong>&gt; &quot;takeGE: Expecting at least 4 elements, got only 3&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.takeGE 4 FL.toList) $ S.fromList [1,0,1,0,1]
</code></strong>&gt; [1,0,1,0,1]
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:lookAhead" class="def">lookAhead</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#lookAhead" class="link">Source</a> <a href="#v:lookAhead" class="selflink">#</a></p><div class="doc"><p>Run a parser without consuming the input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeWhile" class="link">Source</a> <a href="#v:takeWhile" class="selflink">#</a></p><div class="doc"><p>Collect stream elements until an element fails the predicate. The element
 on which the predicate fails is returned back to the input stream.</p><ul><li>Stops - when the predicate fails.</li><li>Fails - never.</li></ul><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.takeWhile (== 0) FL.toList) $ S.fromList [0,0,1,0,1]
</code></strong>&gt; [0,0]
</pre><p>We can implement a <code>breakOn</code> using <code><a href="Streamly-Internal-Data-Parser.html#v:takeWhile" title="Streamly.Internal.Data.Parser">takeWhile</a></code>:</p><pre>breakOn p = takeWhile (not p)
</pre><p><em>Internal</em></p></div></div><div class="doc"><p>Note: This is called <code>takeWhileP</code> and <code>munch</code> in some parser libraries.</p></div><div class="top"><p class="src"><a id="v:takeWhile1" class="def">takeWhile1</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeWhile1" class="link">Source</a> <a href="#v:takeWhile1" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:takeWhile" title="Streamly.Internal.Data.Parser">takeWhile</a></code> but takes at least one element otherwise fails.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:sliceSepBy" class="def">sliceSepBy</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceSepBy" class="link">Source</a> <a href="#v:sliceSepBy" class="selflink">#</a></p><div class="doc"><p>Collect stream elements until an element succeeds the predicate. Drop the
 element on which the predicate succeeded. The succeeding element is treated
 as an infix separator which is dropped from the output.</p><ul><li>Stops - when the predicate succeeds.</li><li>Fails - never.</li></ul><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.sliceSepBy (== 1) FL.toList) $ S.fromList [0,0,1,0,1]
</code></strong>&gt; [0,0]
</pre><p>S.splitOn pred f = S.splitParse (PR.sliceSepBy pred f)</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.splitParse (PR.sliceSepBy (== 1) FL.toList) $ S.fromList [0,0,1,0,1]
</code></strong>&gt; [[0,0],[0],[]]
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:sliceSepByMax" class="def">sliceSepByMax</a> :: MonadCatch m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceSepByMax" class="link">Source</a> <a href="#v:sliceSepByMax" class="selflink">#</a></p><div class="doc"><p>Split using a condition or a count whichever occurs first. This is a
 hybrid of <code>splitOn</code> and <code><a href="Streamly-Internal-Data-Parser.html#v:take" title="Streamly.Internal.Data.Parser">take</a></code>. The element on which the condition succeeds
 is dropped.</p><p><em>Internal</em></p></div></div><div class="doc"><p>Unimplemented</p><pre>, sliceSepByBetween
</pre></div><div class="top"><p class="src"><a id="v:sliceEndWith" class="def">sliceEndWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceEndWith" class="link">Source</a> <a href="#v:sliceEndWith" class="selflink">#</a></p><div class="doc"><p>Collect stream elements until an element succeeds the predicate. Also take
 the element on which the predicate succeeded. The succeeding element is
 treated as a suffix separator which is kept in the output segement.</p><ul><li>Stops - when the predicate succeeds.</li><li>Fails - never.</li></ul><p>S.splitWithSuffix pred f = S.splitParse (PR.sliceEndWith pred f)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:sliceBeginWith" class="def">sliceBeginWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceBeginWith" class="link">Source</a> <a href="#v:sliceBeginWith" class="selflink">#</a></p><div class="doc"><p>Collect stream elements until an elements passes the predicate, return the
 last element on which the predicate succeeded back to the input stream.  If
 the predicate succeeds on the first element itself then it is kept in the
 stream and we continue collecting. The succeeding element is treated as a
 prefix separator which is kept in the output segement.</p><ul><li>Stops - when the predicate succeeds in non-leading position.</li><li>Fails - never.</li></ul><p>S.splitWithPrefix pred f = S.splitParse (PR.sliceBeginWith pred f)</p><p><em>Unimplemented</em></p></div></div><div class="doc"><p>Unimplemented</p><pre>, sliceSepWith

, frameSepBy -- parse frames escaped by an escape char/sequence
, frameEndWith
</pre></div><div class="top"><p class="src"><a id="v:wordBy" class="def">wordBy</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#wordBy" class="link">Source</a> <a href="#v:wordBy" class="selflink">#</a></p><div class="doc"><p>Like <code>splitOn</code> but strips leading, trailing, and repeated separators.
 Therefore, <code>&quot;.a..b.&quot;</code> having <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as the separator would be parsed as
 <code>[&quot;a&quot;,&quot;b&quot;]</code>.  In other words, its like parsing words from whitespace
 separated text.</p><ul><li>Stops - when it finds a word separator after a non-word element</li><li>Fails - never.</li></ul><pre>S.wordsBy pred f = S.splitParse (PR.wordBy pred f)
</pre><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:groupBy" class="def">groupBy</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#groupBy" class="link">Source</a> <a href="#v:groupBy" class="selflink">#</a></p><div class="doc"><p><code>groupBy cmp f $ S.fromList [a,b,c,...]</code> assigns the element <code>a</code> to the
 first group, then if <code>a `cmp` b</code> is <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> <code>b</code> is also assigned to the same
 group.  If <code>a `cmp` c</code> is <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>c</code> is also assigned to the same
 group and so on. When the comparison fails a new group is started. Each
 group is folded using the <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> <code>f</code> and the result of the fold is emitted
 in the output stream.</p><ul><li>Stops - when the comparison fails.</li><li>Fails - never.</li></ul><pre>S.groupsBy cmp f = S.splitParse (PR.groupBy cmp f)
</pre><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:eqBy" class="def">eqBy</a> :: MonadCatch m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a () <a href="src/Streamly.Internal.Data.Parser.html#eqBy" class="link">Source</a> <a href="#v:eqBy" class="selflink">#</a></p><div class="doc"><p>Match the given sequence of elements using the given comparison function.</p><p><em>Internal</em></p></div></div><div class="doc"><p>Unimplemented</p><pre>, prefixOf -- match any prefix of a given string
, suffixOf -- match any suffix of a given string
, infixOf -- match any substring of a given string
</pre></div><a href="#g:4" id="g:4"><h1>Binary Combinators</h1></a><a href="#g:5" id="g:5"><h2>Sequential Applicative</h2></a><div class="top"><p class="src"><a id="v:splitWith" class="def">splitWith</a> :: MonadCatch m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.html#splitWith" class="link">Source</a> <a href="#v:splitWith" class="selflink">#</a></p><div class="doc"><p>Sequential parser application. Apply two parsers sequentially to an input
 stream.  The input is provided to the first parser, when it is done the
 remaining input is provided to the second parser. If both the parsers
 succeed their outputs are combined using the supplied function. The
 operation fails if any of the parsers fail.</p><p>Note: This is a parsing dual of appending streams using
 <code><a href="Streamly-Prelude.html#v:serial" title="Streamly.Prelude">serial</a></code>, it splits the streams using two parsers and zips
 the results.</p><p>This implementation is strict in the second argument, therefore, the
 following will fail:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.splitWith const (PR.satisfy (&gt; 0)) undefined) $ S.fromList [1]
</code></strong></pre><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> instance method <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-60--42--62-" title="Control.Applicative">&lt;*&gt;</a></code>. This implementation allows
 stream fusion but has quadratic complexity. This can fuse with other
 operations and can be faster than <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> instance for small number
 (less than 8) of compositions.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:split_" class="def">split_</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b <a href="src/Streamly.Internal.Data.Parser.html#split_" class="link">Source</a> <a href="#v:split_" class="selflink">#</a></p><div class="doc"><p>Sequential parser application ignoring the output of the first parser.
 Apply two parsers sequentially to an input stream.  The input is provided to
 the first parser, when it is done the remaining input is provided to the
 second parser. The output of the parser is the output of the second parser.
 The operation fails if any of the parsers fail.</p><p>This implementation is strict in the second argument, therefore, the
 following will fail:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (split_ (PR.satisfy (&gt; 0)) undefined) $ S.fromList [1]
</code></strong></pre><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> instance method <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-42--62-" title="Control.Applicative">*&gt;</a></code>. This implementation allows
 stream fusion but has quadratic complexity. This can fuse with other
 operations, and can be faster than <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> instance for small
 number (less than 8) of compositions.</p><p><em>Internal</em></p></div></div><a href="#g:6" id="g:6"><h2>Parallel Applicatives</h2></a><div class="top"><p class="src"><a id="v:teeWith" class="def">teeWith</a> :: MonadCatch m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.html#teeWith" class="link">Source</a> <a href="#v:teeWith" class="selflink">#</a></p><div class="doc"><p><code>teeWith f p1 p2</code> distributes its input to both <code>p1</code> and <code>p2</code> until both
 of them succeed or anyone of them fails and combines their output using <code>f</code>.
 The parser succeeds if both the parsers succeed.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithFst" class="def">teeWithFst</a> :: MonadCatch m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.html#teeWithFst" class="link">Source</a> <a href="#v:teeWithFst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:teeWith" title="Streamly.Internal.Data.Parser">teeWith</a></code> but ends parsing and zips the results, if available,
 whenever the first parser ends.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithMin" class="def">teeWithMin</a> :: MonadCatch m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.html#teeWithMin" class="link">Source</a> <a href="#v:teeWithMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:teeWith" title="Streamly.Internal.Data.Parser">teeWith</a></code> but ends parsing and zips the results, if available,
 whenever any of the parsers ends or fails.</p><p><em>Unimplemented</em></p></div></div><a href="#g:7" id="g:7"><h2>Sequential Interleaving</h2></a><div class="top"><p class="src"><a id="v:deintercalate" class="def">deintercalate</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a y -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b z -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x (y, z) <a href="src/Streamly.Internal.Data.Parser.html#deintercalate" class="link">Source</a> <a href="#v:deintercalate" class="selflink">#</a></p><div class="doc"><p>Apply two parsers alternately to an input stream. The input stream is
 considered an interleaving of two patterns. The two parsers represent the
 two patterns.</p><p>This undoes a &quot;gintercalate&quot; of two streams.</p><p><em>Unimplemented</em></p></div></div><a href="#g:8" id="g:8"><h2>Sequential Alternative</h2></a><div class="top"><p class="src"><a id="v:alt" class="def">alt</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a <a href="src/Streamly.Internal.Data.Parser.html#alt" class="link">Source</a> <a href="#v:alt" class="selflink">#</a></p><div class="doc"><p>Sequential alternative. Apply the input to the first parser and return the
 result if the parser succeeds. If the first parser fails then backtrack and
 apply the same input to the second parser and return the result.</p><p>Note: This implementation is not lazy in the second argument. The following
 will fail:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.satisfy (&gt; 0) `PR.alt` undefined) $ S.fromList [1..10]
</code></strong></pre><p>Compare with <code>Alternative</code> instance method <code>&lt;|&gt;</code>. This implementation allows
 stream fusion but has quadratic complexity. This can fuse with other
 operations and can be much faster than <code>Alternative</code> instance for small
 number (less than 8) of alternatives.</p><p><em>Internal</em></p></div></div><a href="#g:9" id="g:9"><h2>Parallel Alternatives</h2></a><div class="top"><p class="src"><a id="v:shortest" class="def">shortest</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a <a href="src/Streamly.Internal.Data.Parser.html#shortest" class="link">Source</a> <a href="#v:shortest" class="selflink">#</a></p><div class="doc"><p>Shortest alternative. Apply both parsers in parallel but choose the result
 from the one which consumed least input i.e. take the shortest succeeding
 parse.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:longest" class="def">longest</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a <a href="src/Streamly.Internal.Data.Parser.html#longest" class="link">Source</a> <a href="#v:longest" class="selflink">#</a></p><div class="doc"><p>Longest alternative. Apply both parsers in parallel but choose the result
 from the one which consumed more input i.e. take the longest succeeding
 parse.</p><p><em>Internal</em></p></div></div><a href="#g:10" id="g:10"><h1>N-ary Combinators</h1></a><a href="#g:11" id="g:11"><h2>Sequential Collection</h2></a><div class="top"><p class="src"><a id="v:sequence" class="def">sequence</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#sequence" class="link">Source</a> <a href="#v:sequence" class="selflink">#</a></p><div class="doc"><p><code>sequence f t</code> collects sequential parses of parsers in the container <code>t</code>
 using the fold <code>f</code>. Fails if the input ends or any of the parsers fail.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:concatMap" class="def">concatMap</a> :: MonadCatch m =&gt; (b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#concatMap" class="link">Source</a> <a href="#v:concatMap" class="selflink">#</a></p><div class="doc"><p>Map a <code><a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> returning function on the result of a <code><a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code>.</p><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instance method <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:-62--62--61-" title="Control.Monad">&gt;&gt;=</a></code>. This implementation allows
 stream fusion but has quadratic complexity. This can fuse with other
 operations and can be much faster than <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instance for small number
 (less than 8) of compositions.</p><p><em>Internal</em></p></div></div><a href="#g:12" id="g:12"><h2>Sequential Repetition</h2></a><div class="top"><p class="src"><a id="v:count" class="def">count</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#count" class="link">Source</a> <a href="#v:count" class="selflink">#</a></p><div class="doc"><p><code>count n f p</code> collects exactly <code>n</code> sequential parses of parser <code>p</code> using
 the fold <code>f</code>.  Fails if the input ends or the parser fails before <code>n</code>
 results are collected.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:countBetween" class="def">countBetween</a> :: <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#countBetween" class="link">Source</a> <a href="#v:countBetween" class="selflink">#</a></p><div class="doc"><p><code>countBetween m n f p</code> collects between <code>m</code> and <code>n</code> sequential parses of
 parser <code>p</code> using the fold <code>f</code>. Stop after collecting <code>n</code> results. Fails if
 the input ends or the parser fails before <code>m</code> results are collected.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:many" class="def">many</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#many" class="link">Source</a> <a href="#v:many" class="selflink">#</a></p><div class="doc"><p>Collect zero or more parses. Apply the parser repeatedly on the input
 stream, stop when the parser fails, accumulate zero or more parse results
 using the supplied <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>. This parser never fails, in case the first
 application of parser fails it returns an empty result.</p><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:many" title="Control.Applicative">many</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:some" class="def">some</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#some" class="link">Source</a> <a href="#v:some" class="selflink">#</a></p><div class="doc"><p>Collect one or more parses. Apply the supplied parser repeatedly on the
 input stream and accumulate the parse results as long as the parser
 succeeds, stop when it fails.  This parser fails if not even one result is
 collected.</p><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:some" title="Control.Applicative">some</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:manyTill" class="def">manyTill</a> :: MonadCatch m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a x -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#manyTill" class="link">Source</a> <a href="#v:manyTill" class="selflink">#</a></p><div class="doc"><p><code>manyTill f collect test</code> tries the parser <code>test</code> on the input, if <code>test</code>
 fails it backtracks and tries <code>collect</code>, after <code>collect</code> succeeds <code>test</code> is
 tried again and so on. The parser stops when <code>test</code> succeeds.  The output of
 <code>test</code> is discarded and the output of <code>collect</code> is accumulated by the
 supplied fold. The parser fails if <code>collect</code> fails.</p><p><em>Internal</em></p></div></div><a href="#g:13" id="g:13"><h2>Special cases</h2></a><div class="doc"><p>TODO: traditional implmentations of these may be of limited use. For
 example, consider parsing lines separated by <code>\r\n</code>. The main parser
 will have to detect and exclude the sequence <code>\r\n</code> anyway so that we
 can apply the &quot;sep&quot; parser.</p><p>We can instead implement these as special cases of deintercalate.</p><pre>, endBy
, sepBy
, sepEndBy
, beginBy
, sepBeginBy
, sepAroundBy
</pre></div><a href="#g:14" id="g:14"><h1>Distribution</h1></a><div class="doc"><p>A simple and stupid impl would be to just convert the stream to an
 array and give the array reference to all consumers. The array can be
 grown on demand by any consumer and truncated when nonbody needs it.</p></div><a href="#g:15" id="g:15"><h2>Distribute to collection</h2></a><a href="#g:16" id="g:16"><h2>Distribute to repetition</h2></a><a href="#g:17" id="g:17"><h2>Interleaved collection</h2></a><div class="doc"><ol><li>Round robin</li><li>Priority based</li></ol></div><a href="#g:18" id="g:18"><h2>Interleaved repetition</h2></a><div class="doc"><p>repeat one parser and when it fails run an error recovery parser
 e.g. to find a key frame in the stream after an error</p></div><a href="#g:19" id="g:19"><h2>Collection of Alternatives</h2></a><div class="doc"><p>Unimplemented</p><pre>, shortestN
, longestN
, fastestN -- first N successful in time
, choiceN  -- first N successful in position
</pre></div><div class="top"><p class="src"><a id="v:choice" class="def">choice</a> :: t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#choice" class="link">Source</a> <a href="#v:choice" class="selflink">#</a></p><div class="doc"><p><code>choice parsers</code> applies the <code>parsers</code> in order and returns the first
 successful parse.</p></div></div><a href="#g:20" id="g:20"><h2>Repeated Alternatives</h2></a><div class="doc"><pre>, retryMax    -- try N times
, retryUntil  -- try until successful
, retryUntilN -- try until successful n times
</pre></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>