<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Streamly.Internal.Data.Zipper</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Zipper.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">streamly-parsers10: Beautiful Streaming, Concurrent and Reactive Composition</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2020 Composewell Technologies</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Zipper</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Construction</a></li><li><a href="#g:2">Checkpointing</a></li><li><a href="#g:3">Parsing</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A special zipper derived from a stream  to facilitate stream parsing.</p><h1>Zipper</h1><p>The zipper is designed to enable moving backward and forward in the stream
 efficiently to be able to implement backtracking parsers. The zipper can
 buffer data until the parser indicates that it is not needed, we can move
 back in the buffered data if the parser needs to backtrack.</p><h1>Checkpointing</h1><p>We have a checkpointing mechanism built into the zipper to handle
 backtracking. Whenever we enter a computation that can fail and has an
 alternative to run then we add a checkpoint to the zipper. The checkpoint
 ensures that we do not release the buffer upto the checkpoint until this
 computation succeeds, if the computation fails we can backtrack to focus the
 cursor back to the checkpoint position.</p><h1>Future Work</h1><p>We can possibly have a typeclass providing a zipper interface so that we can
 derive a zipper from different data sources efficiently. For example,</p><ul><li>stream zipper</li><li>zippers from different types of arrays</li><li>zipper from a tree of arrays for dynamic in-memory storage</li><li>file handle zipper can utilize the seek to go back and forth in the file</li></ul><p>A tree of zippers where a lower level zipper is dependent on (references
 data in) a higher level zipper could be useful in implementing distributive
 parsers.</p><p>See <a href="https://hackage.haskell.org/package/zipper">https://hackage.haskell.org/package/zipper</a> for an existing type class.
 We need a monadic one.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Zipper">Zipper</a> m a = <a href="#v:Zipper">Zipper</a> [<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>] [a] [a] (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a)</li><li class="src short"><a href="#v:nil">nil</a> :: <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a</li><li class="src short"><a href="#v:fromStream">fromStream</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a</li><li class="src short"><a href="#v:fromList">fromList</a> :: [a] -&gt; <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a</li><li class="src short"><a href="#v:checkpoint">checkpoint</a> :: <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a -&gt; <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a</li><li class="src short"><a href="#v:release">release</a> :: <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a -&gt; <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a</li><li class="src short"><a href="#v:restore">restore</a> :: <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a -&gt; <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a</li><li class="src short"><a href="#v:parse">parse</a> :: MonadCatch m =&gt; (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Parser-ParserD-Types.html#t:Step" title="Streamly.Internal.Data.Parser.ParserD.Types">Step</a> s b)) -&gt; m s -&gt; (s -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a -&gt; m (<a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> b)</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Zipper" class="def">Zipper</a> m a <a href="src/Streamly.Internal.Data.Zipper.html#Zipper" class="link">Source</a> <a href="#t:Zipper" class="selflink">#</a></p><div class="doc"><p><code>Zipper checkpoints lefts rights tail</code>.  The focus is on the first element
 of <code>rights</code>.  <code>lefts</code> is buffered data on the right of the cursor.  <code>tail</code>
 is a stream that is used to generate more data if the cursor moves past
 <code>rights</code>.</p><p><code>checkpoints</code> is a stack of checkpoints. A new checkpoint is created by a
 <code>checkpoint</code> operation. A checkpoint consists of a count that tracks how
 many elements we have yielded after the checkpoint was taken.  We need this
 information to backtrack to the checkpoint.  If we enter a nested
 alternative we add another checkpoint in the stack.  When we exit an
 alternative we call a <code>release</code> on the checkpoint. The <code>release</code> removes the
 checkpoint from the stack and adds its element count to the previous
 checkpoint in the stack. When the last checkpoint is removed the buffer is
 released.</p><p><em>Internal</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Zipper" class="def">Zipper</a> [<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>] [a] [a] (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><a href="#g:1" id="g:1"><h1>Construction</h1></a><div class="top"><p class="src"><a id="v:nil" class="def">nil</a> :: <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a <a href="src/Streamly.Internal.Data.Zipper.html#nil" class="link">Source</a> <a href="#v:nil" class="selflink">#</a></p><div class="doc"><p>Empty zipper.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:fromStream" class="def">fromStream</a> :: <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a <a href="src/Streamly.Internal.Data.Zipper.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><div class="doc"><p>Create a zipper from a stream.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:fromList" class="def">fromList</a> :: [a] -&gt; <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a <a href="src/Streamly.Internal.Data.Zipper.html#fromList" class="link">Source</a> <a href="#v:fromList" class="selflink">#</a></p><div class="doc"><p>Create a zipper from a list.</p><p><em>Internal</em></p></div></div><a href="#g:2" id="g:2"><h1>Checkpointing</h1></a><div class="top"><p class="src"><a id="v:checkpoint" class="def">checkpoint</a> :: <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a -&gt; <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a <a href="src/Streamly.Internal.Data.Zipper.html#checkpoint" class="link">Source</a> <a href="#v:checkpoint" class="selflink">#</a></p><div class="doc"><p>Add a checkpoint to the Zipper so that we do not release the buffer beyond
 the checkpoint.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:release" class="def">release</a> :: <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a -&gt; <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a <a href="src/Streamly.Internal.Data.Zipper.html#release" class="link">Source</a> <a href="#v:release" class="selflink">#</a></p><div class="doc"><p>Release the latest checkpoint, releases any values held by the checkpoint.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:restore" class="def">restore</a> :: <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a -&gt; <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a <a href="src/Streamly.Internal.Data.Zipper.html#restore" class="link">Source</a> <a href="#v:restore" class="selflink">#</a></p><div class="doc"><p>Rewind to restore the cursor to the latest checkpoint.</p><p><em>Internal</em></p></div></div><a href="#g:3" id="g:3"><h1>Parsing</h1></a><div class="top"><p class="src"><a id="v:parse" class="def">parse</a> :: MonadCatch m =&gt; (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Parser-ParserD-Types.html#t:Step" title="Streamly.Internal.Data.Parser.ParserD.Types">Step</a> s b)) -&gt; m s -&gt; (s -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a -&gt; m (<a href="Streamly-Internal-Data-Zipper.html#t:Zipper" title="Streamly.Internal.Data.Zipper">Zipper</a> m a, <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> b) <a href="src/Streamly.Internal.Data.Zipper.html#parse" class="link">Source</a> <a href="#v:parse" class="selflink">#</a></p><div class="doc"><p>Parse a stream zipper using a parser's <code>step</code>, <code>initial</code> and <code>extract</code>
 functions.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>